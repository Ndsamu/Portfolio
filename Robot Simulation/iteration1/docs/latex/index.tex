\hypertarget{index_intro_sec}{}\section{Project Summary}\label{index_intro_sec}
This project implements a simple game where the user controls a robot in attempting to evade obstacles while capturing all bases to win. All gameplay occurs in the \hyperlink{classArena}{Arena} class. This is where time is advanced and all entity interaction is handled. Graphics simulation is generated from the \hyperlink{classGraphicsArenaViewer}{Graphics\+Arena\+Viewer} class which passes user inputs through the controller to the \hyperlink{classArena}{Arena}. All entities are instantiated by the \hyperlink{classEntityFactory}{Entity\+Factory} class which sets each entity to its default parameters. These default parameters vary by class but consist predominantly of a \hyperlink{structPose}{Pose} (position \& heading angle) and radius. Entities exist as subclasses of the \hyperlink{classArenaEntity}{Arena\+Entity} class. The entities consist of the \hyperlink{classArenaMobileEntity}{Arena\+Mobile\+Entity} subclass and \hyperlink{classArenaImmobileEntity}{Arena\+Immobile\+Entity} subclass. At this point in the project, the mobile entities consist of the robot and obstacles. The only immobile entities are the bases of the base class. For the mobile entities, motion is controlled by a \hyperlink{classMotionHandler}{Motion\+Handler} class. Both robots and obstacles have their own motion handler subclasses, \hyperlink{classMotionHandlerRobot}{Motion\+Handler\+Robot} and \hyperlink{classMotionHandlerObstacle}{Motion\+Handler\+Obstacle} respectively. This is where velocity and heading angle of entities are calculated. Upon interaction between entities, for example an obstacle and wall, the \hyperlink{classArena}{Arena} class will adjust the entity overlap in order to ensure entities cannot escape the map or overlap each other (there is a known bug which causes entities to “jump” over each other at times). If the entity interacting with the environment is a robot, then the robots Handle\+Collision method will be called which will decrement the robots lives by one unless the second entity is a base in which the base will be updated to captured (and change color to green) and the robots number of bases captured will be incremented by one. The handle collision method of the robot passes further information to the \hyperlink{classArenaMobileEntity}{Arena\+Mobile\+Entity} subclass of \hyperlink{classSensorTouch}{Sensor\+Touch} which is used to calculate the point of contact between entities. This is used to adjust the overlap between entities. If the robot does lose a life then it is given a mercy invincibility time of two seconds where further lives cannot be lost and the robot’s color will flash. All of this interaction is handled in the arena in the Update\+Entities\+Timestep method. When the user opens the application the simulation will be paused, the user must select the “\+Play” button in order for the arena to begin updating entities. The user can pause the game at any time with the “\+Pause” button and continue play, again with the “\+Play” button. Upon the robot’s lives reaching zero or all bases being captured the robot’s color will change and the game will halt further updates. The user will be allowed to select the New Game which resets all entities by calling their reset method which places them randomly in the arena (except robot which returns to its origin). This also resets robots lives and captured bases. Any base will be set back to uncaptured. 